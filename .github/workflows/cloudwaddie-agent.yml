name: CloudWaddie Agent

on:
  workflow_dispatch:
    inputs:
      prompt:
        description: "Custom prompt"
        required: false
  issue_comment:
    types: [created]

jobs:
  agent:
    runs-on: ubuntu-latest
    # @cloudwaddie-agent mention only (contributors, exclude self)
    if: >-
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'issue_comment' &&
       contains(github.event.comment.body || '', '@cloudwaddie-agent') &&
       (github.event.comment.user.login || '') != 'cloudwaddie-agent' &&
       contains(fromJSON('["OWNER", "MEMBER", "COLLABORATOR", "CONTRIBUTOR"]'), github.event.comment.author_association || ''))

    permissions:
      contents: read

    steps:
      # Checkout with cloudwaddie-agent's PAT
      - uses: actions/checkout@v5
        with:
          token: ${{ secrets.GH_PAT }}
          fetch-depth: 0

      # Git config - commits as cloudwaddie-agent
      - name: Configure Git as cloudwaddie-agent
        run: |
          git config user.name "cloudwaddie-agent"
          git config user.email "cloudwaddie-agent@users.noreply.github.com"

      # gh CLI auth as cloudwaddie-agent
      - name: Authenticate gh CLI as cloudwaddie-agent
        run: |
          echo "${{ secrets.GH_PAT }}" | gh auth login --with-token
          gh auth status

      - name: Ensure tmux is available (Linux)
        if: runner.os == 'Linux'
        run: |
          set -euo pipefail
          if ! command -v tmux >/dev/null 2>&1; then
            sudo apt-get update
            sudo apt-get install -y --no-install-recommends tmux
          fi
          tmux -V

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Checkout oh-my-opencode dev branch
        uses: actions/checkout@v5
        with:
          repository: code-yeongyu/oh-my-opencode
          ref: dev
          path: oh-my-opencode

      - name: Cache Bun dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.bun/install/cache
            oh-my-opencode/node_modules
          key: ${{ runner.os }}-bun-${{ hashFiles('oh-my-opencode/bun.lock') }}
          restore-keys: |
            ${{ runner.os }}-bun-

      # Build oh-my-opencode
      - name: Build oh-my-opencode
        working-directory: oh-my-opencode
        run: |
          bun install
          bun run build

      # Install OpenCode + configure local plugin + auth in single step
      - name: Setup OpenCode with oh-my-opencode
        env:
          OPENCODE_AUTH_JSON: ${{ secrets.OPENCODE_AUTH_JSON }}
        run: |
          export PATH="$HOME/.opencode/bin:$PATH"

          # Install OpenCode (skip if cached)
          if ! command -v opencode &>/dev/null; then
            echo "Installing OpenCode..."
            curl -fsSL https://opencode.ai/install -o /tmp/opencode-install.sh
            
            # Try default installer first, fallback to re-download if it fails
            if file /tmp/opencode-install.sh | grep -q "shell script\|text"; then
              if ! bash /tmp/opencode-install.sh 2>&1; then
                echo "Default installer failed, trying direct install..."
                bash <(curl -fsSL https://opencode.ai/install)
              fi
            else
              echo "Download corrupted, trying direct install..."
              bash <(curl -fsSL https://opencode.ai/install)
            fi
          fi
          opencode --version

          # Run local oh-my-opencode install (uses built dist)
          bun run oh-my-opencode/dist/cli/index.js install --no-tui --claude=no --openai=no --gemini=no --copilot=no

          # Override plugin to use local file reference
          OPENCODE_JSON=~/.config/opencode/opencode.json
          REPO_PATH=$(pwd)/oh-my-opencode
          jq --arg path "file://$REPO_PATH/src/index.ts" '
            .plugin = [.plugin[] | select(. != "oh-my-opencode")] + [$path]
          ' "$OPENCODE_JSON" > /tmp/oc.json && mv /tmp/oc.json "$OPENCODE_JSON"

          # Configure auth if provided, otherwise use free models
          if [[ -n "$OPENCODE_AUTH_JSON" ]]; then
            mkdir -p ~/.local/share/opencode
            echo "$OPENCODE_AUTH_JSON" > ~/.local/share/opencode/auth.json
            chmod 600 ~/.local/share/opencode/auth.json
          else
            echo "No auth provided - using free OpenCode models"
            # Set default model to free tier
            jq '.model = "opencode/big-pickle"' "$OPENCODE_JSON" > /tmp/oc.json && mv /tmp/oc.json "$OPENCODE_JSON"
          fi

          cat "$OPENCODE_JSON"

      # Collect context
      - name: Collect Context
        id: context
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
          EVENT_NAME: ${{ github.event_name }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          COMMENT_BODY: ${{ github.event.comment.body }}
          COMMENT_AUTHOR: ${{ github.event.comment.user.login }}
          COMMENT_ID_VAL: ${{ github.event.comment.id }}
          REPO: ${{ github.repository }}
        run: |
          if [[ "$EVENT_NAME" == "issue_comment" ]]; then
            ISSUE_NUM="$ISSUE_NUMBER"
            AUTHOR="$COMMENT_AUTHOR"
            COMMENT_ID="$COMMENT_ID_VAL"

            # Check if PR or Issue and get title
            ISSUE_DATA=$(gh api "repos/$REPO/issues/${ISSUE_NUM}")
            TITLE=$(echo "$ISSUE_DATA" | jq -r '.title')
            if echo "$ISSUE_DATA" | jq -e '.pull_request' > /dev/null; then
              echo "type=pr" >> $GITHUB_OUTPUT
              echo "number=${ISSUE_NUM}" >> $GITHUB_OUTPUT
            else
              echo "type=issue" >> $GITHUB_OUTPUT
              echo "number=${ISSUE_NUM}" >> $GITHUB_OUTPUT
            fi
            echo "title=${TITLE}" >> $GITHUB_OUTPUT
          fi

          echo "comment<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMENT_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "author=$AUTHOR" >> $GITHUB_OUTPUT
          echo "comment_id=$COMMENT_ID" >> $GITHUB_OUTPUT

      # Add :eyes: reaction (as cloudwaddie-agent)
      - name: Add eyes reaction
        if: steps.context.outputs.comment_id != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          gh api "/repos/${{ github.repository }}/issues/comments/${{ steps.context.outputs.comment_id }}/reactions" \
            -X POST -f content="eyes" || true

      - name: Add working label
        if: steps.context.outputs.number != ''
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          gh label create "cloudwaddie-agent: working" \
            --repo "${{ github.repository }}" \
            --color "fcf2e1" \
            --description "CloudWaddie-agent is currently working on this" \
            --force || true
          
          if [[ "${{ steps.context.outputs.type }}" == "pr" ]]; then
            gh pr edit "${{ steps.context.outputs.number }}" \
              --repo "${{ github.repository }}" \
              --add-label "cloudwaddie-agent: working" || true
          else
            gh issue edit "${{ steps.context.outputs.number }}" \
              --repo "${{ github.repository }}" \
              --add-label "cloudwaddie-agent: working" || true
          fi

      - name: Run oh-my-opencode
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
          USER_COMMENT: ${{ steps.context.outputs.comment }}
          COMMENT_AUTHOR: ${{ steps.context.outputs.author }}
          CONTEXT_TYPE: ${{ steps.context.outputs.type }}
          CONTEXT_NUMBER: ${{ steps.context.outputs.number }}
          CONTEXT_TITLE: ${{ steps.context.outputs.title }}
          REPO_NAME: ${{ github.repository }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
        run: |
          export PATH="$HOME/.opencode/bin:$PATH"

          PROMPT=$(cat <<'PROMPT_EOF'
          [analyze-mode]
          ANALYSIS MODE. Gather context before diving deep:

          CONTEXT GATHERING (parallel):
          - 1-2 explore agents (codebase patterns, implementations)
          - 1-2 librarian agents (if external library involved)
          - Direct tools: Grep, AST-grep, LSP for targeted searches

          IF COMPLEX (architecture, multi-system, debugging after 2+ failures):
          - Consult oracle for strategic guidance

          SYNTHESIZE findings before proceeding.

          ---

          Your username is @cloudwaddie-agent, mentioned by @AUTHOR_PLACEHOLDER in REPO_PLACEHOLDER.

          ## Context
          - Title: TITLE_PLACEHOLDER
          - Type: TYPE_PLACEHOLDER
          - Number: #NUMBER_PLACEHOLDER
          - Repository: REPO_PLACEHOLDER
          - Default Branch: BRANCH_PLACEHOLDER

          ## User's Request
          COMMENT_PLACEHOLDER

          ---

          ## CRITICAL: First Steps (MUST DO BEFORE ANYTHING ELSE)

          ### [CODE RED] MANDATORY CONTEXT READING - ZERO EXCEPTIONS

          **YOU MUST READ ALL CONTENT. NOT SOME. NOT MOST. ALL.**

          1. **READ FULL CONVERSATION** - Execute ALL commands below before ANY other action:
             - **Issues**: `gh issue view NUMBER_PLACEHOLDER --comments`
             - **PRs**: Use ALL THREE commands to get COMPLETE context:
               ```bash
               gh pr view NUMBER_PLACEHOLDER --comments
               gh api repos/REPO_PLACEHOLDER/pulls/NUMBER_PLACEHOLDER/comments
               gh api repos/REPO_PLACEHOLDER/pulls/NUMBER_PLACEHOLDER/reviews
               ```
             
             **WHAT TO EXTRACT FROM THE CONVERSATION:**
             - The ORIGINAL issue/PR description (first message) - this is often the TRUE requirement
             - ALL previous attempts and their outcomes
             - ALL decisions made and their reasoning
             - ALL feedback, criticism, and rejection reasons
             - ANY linked issues, PRs, or external references
             - The EXACT ask from the user who mentioned you
             
             **FAILURE TO READ EVERYTHING = GUARANTEED FAILURE**
             You WILL make wrong assumptions. You WILL repeat past mistakes. You WILL miss critical context.

          2. **CREATE TODOS IMMEDIATELY**: Right after reading, create your todo list using todo tools.
             - First todo: "Summarize issue/PR context and requirements"
             - Break down ALL work into atomic, verifiable steps
             - **GIT WORKFLOW (MANDATORY for implementation tasks)**: ALWAYS include these final todos:
               - "Create new branch from origin/BRANCH_PLACEHOLDER (NEVER push directly to BRANCH_PLACEHOLDER)"
               - "Commit changes"
               - "Create PR to BRANCH_PLACEHOLDER branch"
             - Plan everything BEFORE starting any work

          ---


          Plan everything using todo tools.
          Then investigate and satisfy the request. Only if user requested to you to work explicitly, then use plan agent to plan, todo obsessively then create a PR to `BRANCH_PLACEHOLDER` branch.
          When done, report the result to the issue/PR with `gh issue comment NUMBER_PLACEHOLDER` or `gh pr comment NUMBER_PLACEHOLDER`.
          PROMPT_EOF
          )

          PROMPT="${PROMPT//AUTHOR_PLACEHOLDER/$COMMENT_AUTHOR}"
          PROMPT="${PROMPT//REPO_PLACEHOLDER/$REPO_NAME}"
          PROMPT="${PROMPT//TYPE_PLACEHOLDER/$CONTEXT_TYPE}"
          PROMPT="${PROMPT//NUMBER_PLACEHOLDER/$CONTEXT_NUMBER}"
          PROMPT="${PROMPT//TITLE_PLACEHOLDER/$CONTEXT_TITLE}"
          PROMPT="${PROMPT//BRANCH_PLACEHOLDER/$DEFAULT_BRANCH}"
          PROMPT="${PROMPT//COMMENT_PLACEHOLDER/$USER_COMMENT}"

          stdbuf -oL -eL bun run oh-my-opencode/dist/cli/index.js run "$PROMPT"

      # Push changes (as cloudwaddie-agent)
      - name: Push changes
        if: always()
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          if [[ -n "$(git status --porcelain)" ]]; then
            git add -A
            git commit -m "chore: changes by cloudwaddie-agent" || true
          fi

          BRANCH=$(git branch --show-current)
          if [[ "$BRANCH" != "main" && "$BRANCH" != "master" ]]; then
            git push origin "$BRANCH" || true
          fi

      - name: Update reaction and remove label
        if: always()
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          if [[ -n "${{ steps.context.outputs.comment_id }}" ]]; then
            REACTION_ID=$(gh api "/repos/${{ github.repository }}/issues/comments/${{ steps.context.outputs.comment_id }}/reactions" \
              --jq '.[] | select(.content == "eyes" and .user.login == "cloudwaddie-agent") | .id' | head -1)
            if [[ -n "$REACTION_ID" ]]; then
              gh api -X DELETE "/repos/${{ github.repository }}/reactions/${REACTION_ID}" || true
            fi

            gh api "/repos/${{ github.repository }}/issues/comments/${{ steps.context.outputs.comment_id }}/reactions" \
              -X POST -f content="+1" || true
          fi

          if [[ -n "${{ steps.context.outputs.number }}" ]]; then
            if [[ "${{ steps.context.outputs.type }}" == "pr" ]]; then
              gh pr edit "${{ steps.context.outputs.number }}" \
                --repo "${{ github.repository }}" \
                --remove-label "cloudwaddie-agent: working" || true
            else
              gh issue edit "${{ steps.context.outputs.number }}" \
                --repo "${{ github.repository }}" \
                --remove-label "cloudwaddie-agent: working" || true
            fi
          fi
